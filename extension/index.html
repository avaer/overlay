<!doctype html>
<html>
<head>
<script src="three.js"></script>
<style>
body {
  margin: 0;
}
.body {
  display: flex;
}
.body section {
  display: flex;
  flex: 1;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
}
h1, .body section {
  padding: 0 30px;
}
a {
  text-decoration: underline;
  color: #64b5f6;
  cursor: pointer;
}
a:active {
  color: #1e88e5;
}
#canvas-2d {
  position: absolute;
  pointer-events: none;
  visibility: hidden;
}
</style>
</head>
<body>
  <h1>Home Launcher (OpenVR)</h1>
  <div class=body>
    <section id=apps>
      <h2>Steam Apps</h2>
    </section>
    <section id=processes>
      <h2>Processes</h2>
    </section>
  </div>
  <div class=body>
    <section id=sites>
      <h2>Web Sites</h2>
      <a href="https://immersive-web.github.io/webxr-samples/">WebXR Samples</a>
      <a href="https://immersive-web.github.io/webxr-samples/positional-audio.html">Positional Audio</a>
    </section>
  </div>
  <div class=body>
    <input type=button id=toggle-controls-button value="FPS controls">
    <input type=button id=enter-xr-button value="Enter XR">
  </div>
  <canvas id=canvas-2d></canvas>
<script>

const _fakeXrChrome = {
  async request() {},
};
const xrc = () => window.xrchrome ? window.xrchrome : _fakeXrChrome;

window.addEventListener('xrchromeloaded', async () => {
  const executables = await xrc().request('listSteamApps', []);
  for (const exe of executables) {
    const a = document.createElement('a');
    a.setAttribute('src', `file://${exe}`);
    a.innerHTML = exe;
    a.addEventListener('click', async e => {
      e.preventDefault();

      const res = await xrc().request('launchApp', [
        exe,
      ]);
      const {processId} = res;

      {
        const a2 = document.createElement('a');
        a2.setAttribute('src', `file://${processId}`);
        a2.innerHTML = processId + '';
        a2.addEventListener('click', async e => {
          e.preventDefault();

          await xrc().request('killApp', [
            processId,
          ]);
        });
        document.getElementById('processes').appendChild(a2);
      }
    });
    document.getElementById('apps').appendChild(a);
  }
});
document.addEventListener('pointerlockchange', async e => {
  const isVr = !document.pointerLockElement;
  await xrc().request('setIsVr', [isVr]);
});
const position = new THREE.Vector3(0, 1.5, 0);
const rotation = new THREE.Euler(0, 0, 0, 'YXZ');
const quaternion = new THREE.Quaternion();
const scale = new THREE.Vector3(1, 1, 1);
const velocity = new THREE.Vector3();
const keys = {
  left: false,
  right: false,
  up: false,
  down: false,
}
document.addEventListener('keydown', async e => {
  switch (e.which) {
    case 65: {
      keys.left = true;
      break;
    }
    case 68: {
      keys.right = true;
      break;
    }
    case 87: {
      keys.up = true;
      break;
    }
    case 83: {
      keys.down = true;
      break;
    }
  }
});
document.addEventListener('keyup', async e => {
  switch (e.which) {
    case 65: {
      keys.left = false;
      break;
    }
    case 68: {
      keys.right = false;
      break;
    }
    case 87: {
      keys.up = false;
      break;
    }
    case 83: {
      keys.down = false;
      break;
    }
  }
});
document.addEventListener('mousemove', async e => {
  if (document.pointerLockElement) {
    console.log('got mouse move', e.movementX, e.movementY);

    rotation.y = (rotation.y - e.movementX * Math.PI*2 * 0.001);
    while (rotation.y < -Math.PI*2) {
      rotation.y += Math.PI*2;
    }
    while (rotation.y > Math.PI*2) {
      rotation.y -= Math.PI*2;
    }
    rotation.x = Math.min(Math.max(rotation.x - e.movementY * Math.PI*2 * 0.001, -Math.PI/2), Math.PI/2);
    quaternion.setFromEuler(rotation);

    await xrc().request('setTransform', [
      position.toArray(),
      quaternion.toArray(),
      scale.toArray(),
    ]);
  }
});
window.addEventListener('load', () => {
  const toggleControlsButton = document.getElementById('toggle-controls-button');
  toggleControlsButton.addEventListener('click', async () => {
    await window.document.body.requestPointerLock();
  });

  const canvas2d = document.getElementById('canvas-2d');
  // const ctx = canvas2d.getContext('webgl2');
  async function recurse() {
    velocity.set(0, 0, 0);
    if (keys.left) {
      velocity.x -= 1;
    }
    if (keys.right) {
      velocity.x += 1;
    }
    if (keys.up) {
      velocity.z -= 1;
    }
    if (keys.down) {
      velocity.z += 1;
    }
    if (velocity.length() !== 0) {
      position.add(velocity.normalize().multiplyScalar(0.03));
      await xrc().request('setTransform', [
        position.toArray(),
        quaternion.toArray(),
        scale.toArray(),
      ]);
    }
    window.requestAnimationFrame(recurse);
  }
  window.requestAnimationFrame(recurse);
  
  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    canvas: canvas2d,
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.xr.enabled = true;
  
  const scene = new THREE.Scene();
  const camera = new THREE.Camera();

  const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 2);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);
  const ambientLight = new THREE.AmbientLight(0x808080);
  scene.add(ambientLight);

  const cubeMesh = (() => {
    const geometry = new THREE.BoxBufferGeometry(0.2, 0.2, 0.2);
    const material = new THREE.MeshPhongMaterial({
      color: 0x5c6bc0,
    });
    return new THREE.Mesh(geometry, material);
  })();
  cubeMesh.position.set(0, 1.5, -1);
  scene.add(cubeMesh);

  const _forceTextureInitialization = (() => {
    const material = new THREE.MeshBasicMaterial();
    const geometry = new THREE.PlaneBufferGeometry();
    const scene = new THREE.Scene();
    scene.add(new THREE.Mesh(geometry, material));
    const camera = new THREE.Camera();

    return function _forceTextureInitialization(texture) {
      material.map = texture;
      renderer.render(scene, camera);
    };
  })();
  const _bindTexture = (texture, texId) => {
    _forceTextureInitialization(texture);
    const texProps = renderer.properties.get(texture);
    texProps.__webglTexture = texId;
  };
  const planeMesh = (() => {
    const geometry = new THREE.PlaneBufferGeometry(1, 1);
    const material = new THREE.MeshBasicMaterial({
      color: 0xFFFFFF,
    });
    return new THREE.Mesh(geometry, material);
  })();
  planeMesh.position.set(0, 1.5, -1);
  scene.add(planeMesh);

  (async () => {
    const desc = await xrc().request('prepareBindSurface', []);
    if (desc) {
      console.log('got prepare bind surface', desc);
      const {width, height} = desc;

      const gl = renderer.getContext();
      {
        const error = gl.getError();
        if (error) console.warn('error 1', error);
      }
      const texId = gl.createTexture();
      {
        const error = gl.getError();
        if (error) console.warn('error 2', error);
      }
      gl.bindTexture(gl.TEXTURE_2D, texId);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      const fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texId, 0);
      {
        const error = gl.getError();
        if (error) console.warn('error 3', error);
      }
      gl.clear(gl.COLOR_BUFFER_BIT);
      {
        const error = gl.getError();
        if (error) console.warn('error 4', error);
      }
      // const data = new Uint8Array(width*height*4);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      {
        const error = gl.getError();
        if (error) console.warn('error 5', error);
      }
      gl.flush();
      // console.log('create tex', gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      renderer.state.reset();

      const texture = new THREE.Texture(
        null,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.LinearFilter,
        THREE.LinearFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        0,
        THREE.LinearEncoding
      );
      _bindTexture(texture, texId);
      planeMesh.material.map = texture;
    } else {
      console.warn('no surface to bind');
    }
  })();

  renderer.setAnimationLoop(render);
  function render() {
    cubeMesh.rotation.x += 0.01;
    cubeMesh.rotation.z += 0.01;
  
    renderer.render(scene, camera);
  }

  {
    let currentSession = null;

    function onSessionStarted( session ) {
      session.addEventListener( 'end', onSessionEnded);
      renderer.xr.setSession(session);
      currentSession = session;
    }

    function onSessionEnded( /*event*/ ) {
      currentSession.removeEventListener('end', onSessionEnded);
      currentSession = null;
    }
    
    const enterXrButton = document.getElementById('enter-xr-button');
    enterXrButton.addEventListener('click', async () => {
      const sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor' ] };
      navigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted );
    });
  }
});

</script>
</body>
</html>